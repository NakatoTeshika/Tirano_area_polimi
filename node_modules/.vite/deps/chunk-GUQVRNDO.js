import {
  clear,
  init_obj,
  isEmpty
} from "./chunk-HWY3RNST.js";
import {
  clamp,
  init_math
} from "./chunk-OY5BW2FE.js";
import {
  __esm,
  __export
} from "./chunk-J43GMYXM.js";

// node_modules/ol/events/Event.js
function stopPropagation(evt) {
  evt.stopPropagation();
}
var BaseEvent, Event_default;
var init_Event = __esm({
  "node_modules/ol/events/Event.js"() {
    BaseEvent = class {
      constructor(type) {
        this.propagationStopped;
        this.defaultPrevented;
        this.type = type;
        this.target = null;
      }
      preventDefault() {
        this.defaultPrevented = true;
      }
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
    Event_default = BaseEvent;
  }
});

// node_modules/ol/ObjectEventType.js
var ObjectEventType_default;
var init_ObjectEventType = __esm({
  "node_modules/ol/ObjectEventType.js"() {
    ObjectEventType_default = {
      PROPERTYCHANGE: "propertychange"
    };
  }
});

// node_modules/ol/Disposable.js
var Disposable, Disposable_default;
var init_Disposable = __esm({
  "node_modules/ol/Disposable.js"() {
    Disposable = class {
      constructor() {
        this.disposed = false;
      }
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.disposeInternal();
        }
      }
      disposeInternal() {
      }
    };
    Disposable_default = Disposable;
  }
});

// node_modules/ol/events/EventType.js
var EventType_default;
var init_EventType = __esm({
  "node_modules/ol/events/EventType.js"() {
    EventType_default = {
      CHANGE: "change",
      ERROR: "error",
      BLUR: "blur",
      CLEAR: "clear",
      CONTEXTMENU: "contextmenu",
      CLICK: "click",
      DBLCLICK: "dblclick",
      DRAGENTER: "dragenter",
      DRAGOVER: "dragover",
      DROP: "drop",
      FOCUS: "focus",
      KEYDOWN: "keydown",
      KEYPRESS: "keypress",
      LOAD: "load",
      RESIZE: "resize",
      TOUCHMOVE: "touchmove",
      WHEEL: "wheel"
    };
  }
});

// node_modules/ol/events.js
function listen(target, type, listener, thisArg, once) {
  if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  if (once) {
    const originalListener = listener;
    listener = function() {
      target.removeEventListener(type, listener);
      originalListener.apply(this, arguments);
    };
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}
var init_events = __esm({
  "node_modules/ol/events.js"() {
    init_obj();
  }
});

// node_modules/ol/array.js
function binarySearch(haystack, needle, comparator) {
  let mid, cmp;
  comparator = comparator || ascending;
  let low = 0;
  let high = haystack.length;
  let found = false;
  while (low < high) {
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid;
      found = !cmp;
    }
  }
  return found ? low : ~low;
}
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function descending(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  const n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }
  if (typeof direction === "function") {
    for (let i = 1; i < n; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }
  if (direction > 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n - 1;
  }
  if (direction < 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n - 1;
  }
  for (let i = 1; i < n; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n - 1;
}
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    const tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
function extend(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
function equals(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    const res = compare(arr[index - 1], currentVal);
    return !(res > 0 || strict && res === 0);
  });
}
var init_array = __esm({
  "node_modules/ol/array.js"() {
  }
});

// node_modules/ol/functions.js
function TRUE() {
  return true;
}
function FALSE() {
  return false;
}
function VOID() {
}
function memoizeOne(fn) {
  let called = false;
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!called || this !== lastThis || !equals(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}
function toPromise(getter) {
  function promiseGetter() {
    let value;
    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }
    if (value instanceof Promise) {
      return value;
    }
    return Promise.resolve(value);
  }
  return promiseGetter();
}
var init_functions = __esm({
  "node_modules/ol/functions.js"() {
    init_array();
  }
});

// node_modules/ol/events/Target.js
var Target, Target_default;
var init_Target = __esm({
  "node_modules/ol/events/Target.js"() {
    init_Disposable();
    init_Event();
    init_functions();
    init_obj();
    Target = class extends Disposable_default {
      constructor(target) {
        super();
        this.eventTarget_ = target;
        this.pendingRemovals_ = null;
        this.dispatching_ = null;
        this.listeners_ = null;
      }
      addEventListener(type, listener) {
        if (!type || !listener) {
          return;
        }
        const listeners = this.listeners_ || (this.listeners_ = {});
        const listenersForType = listeners[type] || (listeners[type] = []);
        if (!listenersForType.includes(listener)) {
          listenersForType.push(listener);
        }
      }
      dispatchEvent(event) {
        const isString = typeof event === "string";
        const type = isString ? event : event.type;
        const listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) {
          return;
        }
        const evt = isString ? new Event_default(event) : event;
        if (!evt.target) {
          evt.target = this.eventTarget_ || this;
        }
        const dispatching = this.dispatching_ || (this.dispatching_ = {});
        const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
          dispatching[type] = 0;
          pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        let propagate;
        for (let i = 0, ii = listeners.length; i < ii; ++i) {
          if ("handleEvent" in listeners[i]) {
            propagate = listeners[i].handleEvent(evt);
          } else {
            propagate = listeners[i].call(this, evt);
          }
          if (propagate === false || evt.propagationStopped) {
            propagate = false;
            break;
          }
        }
        if (--dispatching[type] === 0) {
          let pr = pendingRemovals[type];
          delete pendingRemovals[type];
          while (pr--) {
            this.removeEventListener(type, VOID);
          }
          delete dispatching[type];
        }
        return propagate;
      }
      disposeInternal() {
        this.listeners_ && clear(this.listeners_);
      }
      getListeners(type) {
        return this.listeners_ && this.listeners_[type] || void 0;
      }
      hasListener(type) {
        if (!this.listeners_) {
          return false;
        }
        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
      }
      removeEventListener(type, listener) {
        if (!this.listeners_) {
          return;
        }
        const listeners = this.listeners_[type];
        if (!listeners) {
          return;
        }
        const index = listeners.indexOf(listener);
        if (index !== -1) {
          if (this.pendingRemovals_ && type in this.pendingRemovals_) {
            listeners[index] = VOID;
            ++this.pendingRemovals_[type];
          } else {
            listeners.splice(index, 1);
            if (listeners.length === 0) {
              delete this.listeners_[type];
            }
          }
        }
      }
    };
    Target_default = Target;
  }
});

// node_modules/ol/Observable.js
var Observable_exports = {};
__export(Observable_exports, {
  default: () => Observable_default,
  unByKey: () => unByKey
});
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      unlistenByKey(key[i]);
    }
  } else {
    unlistenByKey(key);
  }
}
var Observable, Observable_default;
var init_Observable = __esm({
  "node_modules/ol/Observable.js"() {
    init_Target();
    init_EventType();
    init_events();
    Observable = class extends Target_default {
      constructor() {
        super();
        this.on = this.onInternal;
        this.once = this.onceInternal;
        this.un = this.unInternal;
        this.revision_ = 0;
      }
      changed() {
        ++this.revision_;
        this.dispatchEvent(EventType_default.CHANGE);
      }
      getRevision() {
        return this.revision_;
      }
      onInternal(type, listener) {
        if (Array.isArray(type)) {
          const len = type.length;
          const keys = new Array(len);
          for (let i = 0; i < len; ++i) {
            keys[i] = listen(this, type[i], listener);
          }
          return keys;
        }
        return listen(this, type, listener);
      }
      onceInternal(type, listener) {
        let key;
        if (Array.isArray(type)) {
          const len = type.length;
          key = new Array(len);
          for (let i = 0; i < len; ++i) {
            key[i] = listenOnce(this, type[i], listener);
          }
        } else {
          key = listenOnce(this, type, listener);
        }
        listener.ol_key = key;
        return key;
      }
      unInternal(type, listener) {
        const key = listener.ol_key;
        if (key) {
          unByKey(key);
        } else if (Array.isArray(type)) {
          for (let i = 0, ii = type.length; i < ii; ++i) {
            this.removeEventListener(type[i], listener);
          }
        } else {
          this.removeEventListener(type, listener);
        }
      }
    };
    Observable.prototype.on;
    Observable.prototype.once;
    Observable.prototype.un;
    Observable_default = Observable;
  }
});

// node_modules/ol/util.js
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
var uidCounter_, VERSION;
var init_util = __esm({
  "node_modules/ol/util.js"() {
    uidCounter_ = 0;
    VERSION = "8.2.0";
  }
});

// node_modules/ol/Object.js
var ObjectEvent, BaseObject, Object_default;
var init_Object = __esm({
  "node_modules/ol/Object.js"() {
    init_Event();
    init_ObjectEventType();
    init_Observable();
    init_util();
    init_obj();
    ObjectEvent = class extends Event_default {
      constructor(type, key, oldValue) {
        super(type);
        this.key = key;
        this.oldValue = oldValue;
      }
    };
    BaseObject = class extends Observable_default {
      constructor(values) {
        super();
        this.on;
        this.once;
        this.un;
        getUid(this);
        this.values_ = null;
        if (values !== void 0) {
          this.setProperties(values);
        }
      }
      get(key) {
        let value;
        if (this.values_ && this.values_.hasOwnProperty(key)) {
          value = this.values_[key];
        }
        return value;
      }
      getKeys() {
        return this.values_ && Object.keys(this.values_) || [];
      }
      getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {};
      }
      getPropertiesInternal() {
        return this.values_;
      }
      hasProperties() {
        return !!this.values_;
      }
      notify(key, oldValue) {
        let eventType;
        eventType = `change:${key}`;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
        eventType = ObjectEventType_default.PROPERTYCHANGE;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
      }
      addChangeListener(key, listener) {
        this.addEventListener(`change:${key}`, listener);
      }
      removeChangeListener(key, listener) {
        this.removeEventListener(`change:${key}`, listener);
      }
      set(key, value, silent) {
        const values = this.values_ || (this.values_ = {});
        if (silent) {
          values[key] = value;
        } else {
          const oldValue = values[key];
          values[key] = value;
          if (oldValue !== value) {
            this.notify(key, oldValue);
          }
        }
      }
      setProperties(values, silent) {
        for (const key in values) {
          this.set(key, values[key], silent);
        }
      }
      applyProperties(source) {
        if (!source.values_) {
          return;
        }
        Object.assign(this.values_ || (this.values_ = {}), source.values_);
      }
      unset(key, silent) {
        if (this.values_ && key in this.values_) {
          const oldValue = this.values_[key];
          delete this.values_[key];
          if (isEmpty(this.values_)) {
            this.values_ = null;
          }
          if (!silent) {
            this.notify(key, oldValue);
          }
        }
      }
    };
    Object_default = BaseObject;
  }
});

// node_modules/ol/CollectionEventType.js
var CollectionEventType_default;
var init_CollectionEventType = __esm({
  "node_modules/ol/CollectionEventType.js"() {
    CollectionEventType_default = {
      ADD: "add",
      REMOVE: "remove"
    };
  }
});

// node_modules/ol/Collection.js
var Property, CollectionEvent, Collection, Collection_default;
var init_Collection = __esm({
  "node_modules/ol/Collection.js"() {
    init_Object();
    init_CollectionEventType();
    init_Event();
    Property = {
      LENGTH: "length"
    };
    CollectionEvent = class extends Event_default {
      constructor(type, element, index) {
        super(type);
        this.element = element;
        this.index = index;
      }
    };
    Collection = class extends Object_default {
      constructor(array, options) {
        super();
        this.on;
        this.once;
        this.un;
        options = options || {};
        this.unique_ = !!options.unique;
        this.array_ = array ? array : [];
        if (this.unique_) {
          for (let i = 0, ii = this.array_.length; i < ii; ++i) {
            this.assertUnique_(this.array_[i], i);
          }
        }
        this.updateLength_();
      }
      clear() {
        while (this.getLength() > 0) {
          this.pop();
        }
      }
      extend(arr) {
        for (let i = 0, ii = arr.length; i < ii; ++i) {
          this.push(arr[i]);
        }
        return this;
      }
      forEach(f) {
        const array = this.array_;
        for (let i = 0, ii = array.length; i < ii; ++i) {
          f(array[i], i, array);
        }
      }
      getArray() {
        return this.array_;
      }
      item(index) {
        return this.array_[index];
      }
      getLength() {
        return this.get(Property.LENGTH);
      }
      insertAt(index, elem) {
        if (index < 0 || index > this.getLength()) {
          throw new Error("Index out of bounds: " + index);
        }
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(
          new CollectionEvent(CollectionEventType_default.ADD, elem, index)
        );
      }
      pop() {
        return this.removeAt(this.getLength() - 1);
      }
      push(elem) {
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        const n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
      }
      remove(elem) {
        const arr = this.array_;
        for (let i = 0, ii = arr.length; i < ii; ++i) {
          if (arr[i] === elem) {
            return this.removeAt(i);
          }
        }
        return void 0;
      }
      removeAt(index) {
        if (index < 0 || index >= this.getLength()) {
          return void 0;
        }
        const prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(
          new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
        );
        return prev;
      }
      setAt(index, elem) {
        const n = this.getLength();
        if (index >= n) {
          this.insertAt(index, elem);
          return;
        }
        if (index < 0) {
          throw new Error("Index out of bounds: " + index);
        }
        if (this.unique_) {
          this.assertUnique_(elem, index);
        }
        const prev = this.array_[index];
        this.array_[index] = elem;
        this.dispatchEvent(
          new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
        );
        this.dispatchEvent(
          new CollectionEvent(CollectionEventType_default.ADD, elem, index)
        );
      }
      updateLength_() {
        this.set(Property.LENGTH, this.array_.length);
      }
      assertUnique_(elem, except) {
        for (let i = 0, ii = this.array_.length; i < ii; ++i) {
          if (this.array_[i] === elem && i !== except) {
            throw new Error("Duplicate item added to a unique collection");
          }
        }
      }
    };
    Collection_default = Collection;
  }
});

// node_modules/ol/asserts.js
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
var init_asserts = __esm({
  "node_modules/ol/asserts.js"() {
  }
});

// node_modules/ol/layer/Property.js
var Property_default;
var init_Property = __esm({
  "node_modules/ol/layer/Property.js"() {
    Property_default = {
      OPACITY: "opacity",
      VISIBLE: "visible",
      EXTENT: "extent",
      Z_INDEX: "zIndex",
      MAX_RESOLUTION: "maxResolution",
      MIN_RESOLUTION: "minResolution",
      MAX_ZOOM: "maxZoom",
      MIN_ZOOM: "minZoom",
      SOURCE: "source",
      MAP: "map"
    };
  }
});

// node_modules/ol/layer/Base.js
var BaseLayer, Base_default;
var init_Base = __esm({
  "node_modules/ol/layer/Base.js"() {
    init_Object();
    init_Property();
    init_util();
    init_asserts();
    init_math();
    BaseLayer = class extends Object_default {
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        this.background_ = options.background;
        const properties = Object.assign({}, options);
        if (typeof options.properties === "object") {
          delete properties.properties;
          Object.assign(properties, options.properties);
        }
        properties[Property_default.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
        assert(
          typeof properties[Property_default.OPACITY] === "number",
          "Layer opacity must be a number"
        );
        properties[Property_default.VISIBLE] = options.visible !== void 0 ? options.visible : true;
        properties[Property_default.Z_INDEX] = options.zIndex;
        properties[Property_default.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
        properties[Property_default.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
        properties[Property_default.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
        properties[Property_default.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
        this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
        delete properties.className;
        this.setProperties(properties);
        this.state_ = null;
      }
      getBackground() {
        return this.background_;
      }
      getClassName() {
        return this.className_;
      }
      getLayerState(managed) {
        const state = this.state_ || {
          layer: this,
          managed: managed === void 0 ? true : managed
        };
        const zIndex = this.getZIndex();
        state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
      }
      getLayersArray(array) {
        return abstract();
      }
      getLayerStatesArray(states) {
        return abstract();
      }
      getExtent() {
        return this.get(Property_default.EXTENT);
      }
      getMaxResolution() {
        return this.get(Property_default.MAX_RESOLUTION);
      }
      getMinResolution() {
        return this.get(Property_default.MIN_RESOLUTION);
      }
      getMinZoom() {
        return this.get(Property_default.MIN_ZOOM);
      }
      getMaxZoom() {
        return this.get(Property_default.MAX_ZOOM);
      }
      getOpacity() {
        return this.get(Property_default.OPACITY);
      }
      getSourceState() {
        return abstract();
      }
      getVisible() {
        return this.get(Property_default.VISIBLE);
      }
      getZIndex() {
        return this.get(Property_default.Z_INDEX);
      }
      setBackground(background) {
        this.background_ = background;
        this.changed();
      }
      setExtent(extent) {
        this.set(Property_default.EXTENT, extent);
      }
      setMaxResolution(maxResolution) {
        this.set(Property_default.MAX_RESOLUTION, maxResolution);
      }
      setMinResolution(minResolution) {
        this.set(Property_default.MIN_RESOLUTION, minResolution);
      }
      setMaxZoom(maxZoom) {
        this.set(Property_default.MAX_ZOOM, maxZoom);
      }
      setMinZoom(minZoom) {
        this.set(Property_default.MIN_ZOOM, minZoom);
      }
      setOpacity(opacity) {
        assert(typeof opacity === "number", "Layer opacity must be a number");
        this.set(Property_default.OPACITY, opacity);
      }
      setVisible(visible) {
        this.set(Property_default.VISIBLE, visible);
      }
      setZIndex(zindex) {
        this.set(Property_default.Z_INDEX, zindex);
      }
      disposeInternal() {
        if (this.state_) {
          this.state_.layer = null;
          this.state_ = null;
        }
        super.disposeInternal();
      }
    };
    Base_default = BaseLayer;
  }
});

export {
  stopPropagation,
  Event_default,
  init_Event,
  ObjectEventType_default,
  init_ObjectEventType,
  Disposable_default,
  init_Disposable,
  binarySearch,
  ascending,
  descending,
  linearFindNearest,
  reverseSubArray,
  extend,
  equals,
  isSorted,
  init_array,
  TRUE,
  FALSE,
  VOID,
  memoizeOne,
  toPromise,
  init_functions,
  Target_default,
  init_Target,
  EventType_default,
  init_EventType,
  listen,
  listenOnce,
  unlistenByKey,
  init_events,
  Observable_default,
  Observable_exports,
  init_Observable,
  abstract,
  getUid,
  VERSION,
  init_util,
  Object_default,
  init_Object,
  CollectionEventType_default,
  init_CollectionEventType,
  Collection_default,
  init_Collection,
  assert,
  init_asserts,
  Property_default,
  init_Property,
  Base_default,
  init_Base
};
//# sourceMappingURL=chunk-GUQVRNDO.js.map
